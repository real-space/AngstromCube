\documentclass[oribibl]{llncs}

\usepackage{units}
\usepackage{psfrag} %% psfrac does not work with pdflatex
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{subfigure}
\usepackage{todonotes} %% add [disable] to disable
\usepackage{transparent}
\usepackage{pgfplots}
\usepackage{gensymb} %% \degree
\usepackage{pdflscape} %% or lscape
%\usepackage[acronym]{glossaries}


\usepackage{acronym} %% for abbreviations
%% physics related abbreviations
\acrodef{DFT}[DFT]{density functional theory}
\acrodef{XC}[XC]{exchange-correlation}
\acrodef{SHO}[SHO]{spherical harmonic oscillator}
\acrodef{DOS}[DoS]{density of states}
\acrodef{HO}[HO]{harmonic oscillator}
\acrodef{PW}[PW]{plane wave}
\acrodef{GP}[GP]{grid point}
\acrodef{AE}[AE]{all-electron}
\acrodef{PAW}[PAW]{Projector Augmented Wave}
%% computer science related abbreviations
\acrodef{CPU}[CPU]{central processing unit}
\acrodef{GPU}[GPU]{graphical processing unit}
\acrodef{HPC}[HPC]{high performance computing}
\acrodef{OMP}[OpenMP]{OpenMP}
\acrodef{MPI}[MPI]{message passing interface}
\acrodef{SCF}[SCF]{self-consistent field}
\acrodef{RHS}[RHS]{right-hand side}
\acrodef{XML}[XML]{eXtendable Markup Language}
\acrodef{API}[API]{application programming interface}


\setlength{\tabcolsep}{6pt}

\newcommand{\um}[1]{_{\mathrm{#1}}}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\lmax}{\ell_{\mathrm{max}}}
\newcommand{\ellm}{L}
\newcommand{\nrn}{n_{\mathrm{r}}}
\newcommand{\ket}[1]{\left| #1 \right\rangle}
\newcommand{\bra}[1]{\left\langle #1 \right|}
\newcommand{\braket}[2]{\left\langle \left. #1 \right| #2 \right\rangle}
\newcommand{\braketop}[3]{\left\langle \left. #1 \right| #2 \left| #3 \right. \right\rangle}
\newcommand{\fullcodename}{AngstromCube}
\newcommand{\codename}{A43}

%\makeglossaries


\begin{document}
\pagestyle{plain}

\title       {\fullcodename{} User Manual}
\titlerunning{\codename{} User Manual}

\author{%
  Paul F.~Baumeister\inst{1} % \and %
}

\institute{%
  J\"{u}lich Supercomputing Centre, Forschungszentrum J\"{u}lich, 52425 J\"{u}lich, Germany
%   \and Institute for Advanced Simulation, Forschungszentrum J\"{u}lich, 52425 J\"{u}lich, Germany
}

\maketitle

\begin{figure*}
	\centering
	\includegraphics[width=3cm]{fig/a43_logo_bold_no_helper_lines} %%
\end{figure*}

% ==============================================================================
\begin{abstract}
This is a user manual for everyone who is interested in using
this software.
As far as possible, all aspects of programming are omitted here.
However, some aspects related to the algorithms that the applications 
makes use of will need be covered in order to explain the handling.
\end{abstract}
% ==============================================================================

\newpage

\tableofcontents

\section*{How to read this document?}
\todo[inline]{Write}



\newpage

% ==============================================================================
\section{Introduction} \label{sec:intro}
% ==============================================================================
%
\fullcodename{} (\codename{}) is an implementation for performing calculations 
in the framework of \ac{DFT}.
Readers familiar with the theory may jump to the description of 
features of \codename{} in Section \ref{sec:features}.

\subsection{Density Functional Theory} \label{sec:short-theory}
%
A fair number of books and a vast number of articles in the scientific 
literature is on \ac{DFT}, therefore, we will only give a brief recap 
of the very basics needed to understand what kind of physics can be
simulated with \codename{} and also, where the limitations of predictive power
are.

\ac{DFT} is a ground state method, this means that in principle we have to
assume zero Kelvin. However, you will see later that for special situations 
finite temperatures are applied to smear out the Fermi-Dirac distribution 
for electronic occupation numbers in order to improve convergence.
In principle, all results should be extrapolated to \unit[0]{K}.


The underlying Hohenberg-Kohn theorem tells us, that we can derive some 
ground state properties of the system once we have found the correct density.
In order to find the density, Kohn and Sham introduced single-particle wave functions $\Psi_i$, 
which are eigenstates of an effective single-particle Hamiltonian $\hat H$.
With a little simplification, we can write the total electron density
\begin{equation}
	n(\vec r) = \sum_i^{\mathrm{occ}} \left| \Psi_i(\vec r) \right|^2
	\label{eqn:simplified_density_generation}
\end{equation} 
As a function or functional of the density $n(\vec r)$ we can construct
a local effective potential entering the Hamiltonian
\begin{equation}
	\hat H\um{Kohn-Sham} = \frac{\left( \imath \hbar \vec \nabla \right)^2}{2 m_e} + V\um{eff}(\vec r)
	\label{eqn:Kohn-Sham_Hamiltonian_no_spin}
\end{equation} 
where $V\um{eff}(\vec r)$ includes
\begin{itemize}
  \item the attractive Coulomb potential of the atomic nuclei,
  \item a repulsive Hartree potential from electrostatic 
  		interaction of an electron with the density,
  \item potential external fields and
  \item a contribution accounting for exchange and electronic correlation.
\end{itemize}

\subsection{The Exchange-Correlation Functional} \label{sec:xc-functional}
%
The true many-body wave function for a system with electrons (as being Fermions)
is anti-symmetric under exchange of two particles. 
This implies that e.g.~a two-electron wave function $\Psi(\vec r_1,\vec r_2)$ must be zero 
whenever $\vec r_1 \rightarrow \vec r_2$ in order to obey the anti-symmetry constraint.
This lowers the repulsion energy of a real two-electrons system compared to a
system of independent charged particles.
Different from the Hartree-Fock method where a Slater determinant takes care of the antisymmetry exactly
in \ac{DFT} the construction of independent single-particle states 
is an approximation that requires to model the exchange interaction.

Furthermore, there are correlation effects of true many-body electron systems
which also need to be modelled in both, \ac{DFT} and Hartree-Fock.
Exchange and correlation effects together are modelled in the contribution $V\um{xc}(\vec r)$ 
to the total effective potential and a corresponding energy density $\epsilon\um{xc}$ for the evaluation of a total energy.

Different parametrizations of the \ac{XC} functional are available.
\codename{} focusses onto the three classes of (semi-)local, non-orbital dependent functionals: 
\begin{itemize}
	\item Local (Spin) Density Approximation, LDA/LSDA, 
	\item Generalized Gradient Approximation, GGA
	\item Meta-GGA
\end{itemize}
LDAs generate $V(\vec r)$ only from the value of $n(\vec r)$, 
hence the name \emph{local}. 
GGAs include some gradients of the density, $|\vec \nabla n(\vec r)|$.
Still, the spatial argument $\vec r$ is the same but thinking for example
in terms of finite-difference derivatives on a grid, 
a slightly non-local character of GGAs becomes visible.
Finally, meta-GGAs incorporate information about the kinetic energy density.
In analogy to eq.~(\ref{eqn:simplified_density_generation}), the kinetic energy density $\tau$ can be found by
\begin{equation}
	\tau(\vec r) = \frac{\hbar^2}{2m_e} \sum_i^{\mathrm{occ}} \braketop{ \Psi_i } {\vec \nabla^2 } { \Psi_i } 
	\label{eqn:simplified_kinetic_energy_density_generation}
\end{equation}
where we introduced Dirac's \emph{bra-ket} notation.
Currently, only the 
%Perdew-Zunger'81 \ttt{PZ81}
Perdew-Wang'91 \ttt{PW91}-LDA is implemented
but it is planned to interface \ttt{libxc} with access to most existing functionals.
\todo[inline]{Implement LIBXC, reference for LIBXC}

\subsection{Code Features} \label{sec:features}
%
\codename{} is an all-electron \ac{DFT} application 
based on the \ac{PAW} method \cite{PhysRevB.50.17953} % Bloechl 1994
with the extension of analytical projectors \cite{BaumeisterTsukamoto2019}
where the projectors are expanded in eigenfunctions of a \ac{SHO}.
\ttt{C++} has been chosen for its expressivity
when it comes to mult-precision algorithms
and its good interoperability with common \ac{GPU} programming models.

\noindent
For an up-to-date list of the code features, please see the \ttt{README.md} file.

\section{How to get started} \label{sec:how-to-get-started}
%
\subsection{Getting the Code} \label{sec:getting-the-code}
\codename{} is released under the MIT license and can be accessed at \\
\ttt{https://github.com/real-space/AngstromCube} 

\subsection{Building the Application} \label{sec:compiling}
%
Two \ttt{Makefile}s are contained in the folders \ttt{src/} and \ttt{green/} that work with current compilers, e.g.~\ttt{GNU c++ 7.4.0} or \ttt{clang 14.0.0}.
Alternatively, \ttt{CMake} is supported for most configurations.
\todo[inline]{Make sure CMake runs}

\noindent
The application \codename{}, while being written in \ttt{C++}, strongly relies on plane-old-data types,
i.e.~classes without constructors or destructors as known from C-structs.
Furthermore, it makes use of generic programming in the form of templates
mainly used to maintain a single function supporting different precision (\ttt{float} or \ttt{double}), 
difference vector lengths, \ttt{real} and \ttt{complex} and in some situations different physics.
This helps to keep the code base small and, hence, maintainable.

\section{Basic Handling} \label{sec:basic-handling}
%
\fullcodename{} or short \codename{} comes in two executables named \ttt{./a43} and \ttt{./green} which
offer many functionalities accessible by options. Type \ttt{./a43 --help}
to get a first-aid function:
\begin{verbatim}
Usage ./a43 [OPTION]
   --help           [-h]	This help message
   --version            	Show version number
   --test <module>  [-t]	Run module unit test
   --verbose        [-V]	Increment verbosity level
   +<name>=<value>      	Modify variable environment
\end{verbatim}

\noindent
An important functionality after building the application (see Section \ref{sec:compiling})
is to run the unit tests of the available modules.
In order to get a list of available modules, use 
\begin{verbatim}
./a43 --test '?'
\end{verbatim}
where the high quotes are necessary so your shell does not try to interpret the question mark.
Pass the name of one of the listed modules to run a module unit test like this:
\begin{verbatim}
./a43 --test complex_tools
\end{verbatim}
We can also run the unit test of all modules, however, for this we might want to reduce
the amount of output to \ttt{stdout}.
We may use the variable environment 
\footnote{The internal variable environment of \codename{} is not linked to that of the shell.}
which couples to the command line interface with a leading \ttt{+}. For example use
\begin{verbatim}
./a43 +verbosity=1 --test
\end{verbatim}
to change the \ttt{+verbosity} to minimal when running all unit tests.
Table \ref{tab:verbosity-level-meaning} shows \ttt{+verbosity} ranges in detail.


\noindent
The default \ttt{+verbosity} level is $3$ and levels are adjusted occasionally during development.
However, the ground rule says that higher \ttt{+verbosity} means more output
and \ttt{verbosity=0} suppresses all output except for warnings and fatal errors.
We can also use the options \ttt{--verbose} to set \ttt{+verbosity=6} (high)
or fine tune the verbosity level by adding +$1$ for every \ttt{-v} and +$4$ for every \ttt{-V} in the command line.
Table \ref{tab:verbosity-level-meaning} gives a rough overview on verbosity levels.
\noindent
There are many more control variables like \ttt{verbosity} in \codename{}.
Section \ref{sec:list-of-control-variables} and Table \ref{tab:control-show-details} 
will explain how to get an overview of their values.


\begin{table}[ht!]
\caption[Meaning of verbosity levels]{
Meaning of \ttt{+verbosity} levels
\todo[inline]{Is this table needed?}
} \label{tab:verbosity-level-meaning}
\centering
\begin{tabular}{|r|l|}
\hline
  \ttt{verbosity} & Meaning   \\
\hline
     0 & No output whatsoever \\
     1 & Minimal output       \\
     3 & Default low          \\
  5--7 & High detail          \\
   $\geq$ 8 & Debugging       \\
\hline
\end{tabular}
\end{table}


\subsection{Atomic Units, Input and Output} \label{sec:units}
%
Internally \codename{} makes use of Hartree atomic units:
\begin{equation}
	\hbar = m_e = e = 1
\end{equation}
as this reduces the number of non-trivial factors in many equations.
This means that the internal unit of length is Bohr = \unit[0.529177]{\AA{}}
and the internal unit of energy is Hartree = \unit[27.2114]{$e$V}.
However, we can change the length and energy units used for output like this:
\begin{verbatim}
./a43 +output.energy.unit=eV +output.length.unit=Ang ...
\end{verbatim}
%% sigma_config uses Bohr always (as input and output unit) on purpose
Available output units are \ttt{eV}, \ttt{Kelvin}, \ttt{Ry} or \ttt{Ha} (default) for energies 
and \ttt{nm}, \ttt{pm}, \ttt{Ang} (=\AA) and \ttt{Bohr} (default) for lengths. Run
\begin{verbatim}
./a43 --test unit_system
\end{verbatim}
to verify this.
%
Input length units are \AA{} in the \ttt{geometry.file} as this is most convenient for molecular structure viewers
(\ttt{VESTA}, \ttt{jmol}, etc). Other input quantities may have flexible input units, for example
\begin{verbatim}
... +logder.unit=Ry +logder.step=1e-3
\end{verbatim}
which means that the energy spacing for checking of the logarithmic derivatives is \unit[$10^{-3}$]{Rydberg}.
The same input unit is assumed for \ttt{+logder.start} and \ttt{+logder.stop}.

\noindent
Experimental parts of the code may not support the flexible unit conversion
factors for output. Then you should be able to find at least indications as \ttt{Ha}, \ttt{Bohr} or simply \ttt{a.u.} in the log files.
Most standard functionality, however, supports unit conversion as described above.
Some quantities are displayed in characteristic units, e.g., plane wave cutoff energies are typically shown also in \ttt{Rydberg}.


\subsection{First Steps} \label{sec:first-steps}
%
Make sure there is a \ttt{jmol}-viewable\footnote{Available for free download or via molview.org} structure file \ttt{atoms.xyz}
with atomic coordinates given in \AA{}ngstr\"{o}m and run
\begin{verbatim}
./a43 --test geometry_analysis
\end{verbatim}
in order to check if your geometry looks ok.
More details on what the \ttt{geometry\_analysis} output tells you can be found in Section \ref{sec:geometry-analysis}.
You can search the log file for warnings using \ttt{grep} but
if the code finalizes regularly
there will also be a summary of all warnings launched during execution at the end of the log file.
% For a detailed description of the usage of \ttt{geometry\_analysis} see Section \ref{sec:geometry-analysis}.
%

\noindent
Once free of warnings, continue with the next step:
Let's say we want aluminum in our system, then run:
\begin{verbatim}
./a43 --test single_atom +single_atom.test.Z=13
\end{verbatim}
See Section \ref{sec:single-atom} for more details on \ttt{single\_atom}.
\todo[inline]{Currently, aluminum produces a critical charge deficit operator eigenvalue}
%
\noindent
\codename{} will then try to access a database of initial atomic potentials
(full spherically, spin-degenerate) which are stored in \ttt{./pot/Zeff.}$00Z$
where $00Z$ is a 3-digit integer atomic number.
\todo[inline]{make the path to pot/ configurable}
You can even add \ttt{+single\_atom.init.scf.maxit=33} to let the atomic density relax for $33$ iterations if e.g.~the \ac{XC} functional differs from the one that was used to generate the \ttt{Zeff.}-file.

\noindent
If the loading fails because of a missing file, 
\codename{} will try to bootstrap itself and generate the missing file \ttt{./pot/Zeff.}$00Z$.
\begin{verbatim}
./a43 --test atom_core +atom_core.test.Z=13
\end{verbatim}
You can, however, enforce to generate all these files by
\begin{verbatim}
./a43 --test atom_core \
        +atom_core.test.Z=1 +atom_core.test.Z.end=86
\end{verbatim}
This may take some minutes. To track the progress, \ttt{+verbosity=5} is recommended.
More details on \ttt{atom\_core} can be found in Section \ref{sec:atom-core}.
\todo[inline]{OpenMP would be good here}
%
\noindent
Now, run the \ttt{single\_atom} test for each of the elements in the system 
to see if there are warnings before you continue with the main calculation
\begin{verbatim}
./a43 --test self_consistency \
        +geometry.file=molecule.xyz
\end{verbatim}
\todo[inline]{we have not yet defined a functionality of main! only tests so far. Maybe we will never}
%

%
\subsection{Writing an input file} \label{sec:control-file}
%
At some point the command line becomes full.
We can pass more environment variables to \codename{} using a \ttt{+control.file}, e.g.:
\begin{verbatim}
./a43 --test potential_generator +control.file=control.sh
\end{verbatim}
Hint: There is no default name or naming scheme for the control file 
but it may be helpful to use an \ttt{.sh}-file extension since that
enables useful syntax highlighting and commenting functionality in common text editors.
In most examples, we use the name \ttt{control.sh}.
%
%

\subsubsection{Control File Rules} \label{sec:control-file-rules}
%
Lines in a control file are either 
\begin{itemize}
    \item empty
    \item silent comments starting from \ttt{\#}
    \item comments with \ttt{\#!} which appear in the log output or
    \item $variablename$\ttt{=}$value$
\end{itemize}
where $value$ is the string between \lq\ttt{=}\rq and the line end and may contain whitespace characters.
\\
Mind: We must not place \ttt{+} in front of $variablename$ when specified in a control file!
We may add blanks after \lq\ttt{=}\rq for numeric values but not before the \lq\ttt{=}\rq.
\\
A repeated $variablename$ will launch a warning about redefinition, even if the value is unchanged. Try
\begin{verbatim}
./a43 +a=5 +a=5
\end{verbatim}
Variable names may contain any character except \lq\ttt{=}\rq.

\subsubsection{List of Control Variables} \label{sec:list-of-control-variables}
%
Use e.g.~\ttt{+control.show=1} to display all environment variables used during execution.
Set \ttt{+control.show=2} to show only the unused variables, \ttt{=4} to show also those variables that have their default values, \ttt{6} for both.
In order to get information where the variable's value originated and how many times it was used, invert the same number as above into their negatives, i.e.~\ttt{-1}, \ttt{-2}, \ttt{-4} and \ttt{-6}.
See Tab \ref{tab:control-show-details} for decoding the origin. 
%
%
\begin{table}[ht!]
\caption[Variable value origins]{
Variable value origins shown with \ttt{+control.show=-6}
} \label{tab:control-show-details}
\centering
\begin{tabular}{|l|l|}
\hline
  	 \ttt{Detail}    & Meaning   \\
\hline
     \verb+def  0+   & Variable has its default value      \\
     \verb+set  0+   & Value was set using \ttt{control::set()} \\
     \ttt{argv \#}   & Command line argument number \\
     \ttt{line \#}   & Line number in the \ttt{+control.file} \\
\hline
\end{tabular}
\end{table}


\subsection{Parallel Computing} \label{sec:parallelization}
%
Currently, only the \ttt{geometry\_analysis} part of \codename{} supports shared memory parallelism 
via \ac{OMP} threads on the \ac{CPU}.
In order to target current \ac{HPC} systems 
the executable \ttt{./green} incorporates the \ac{MPI} library
for inter-node communication
and the \ttt{CUDA} programming model for acceleration by a \ac{GPU}.
When \ac{MPI} and \ac{GPU}s are employed, multi-\ac{GPU} parallelisation is achieved
with exactly one device per \ac{MPI} rank.

\noindent
Please consult with your \ac{HPC} system administrator for support
about how to control and place the different levels of parallelism.

\section{Representation of Wave Functions} \label{sec:representation}
%
Kohn-Sham eigenstates have very different character depending on their energy level: core states, valence states and depending on the species also semicore states. The following sections will give a short overview of their treatment in \codename{}.
%
%
\subsection{Treatment of Core States} \label{sec:core-states}
%
Core states are very low in energy and strongly bound to the atomic core.
Their spatial extent is strongly localized in the vicinity of the atomic nucleus
so that they feel almost exclusively the strong attractive Coulomb potential of the core. 
This can be approximated fairly well as a spherically symmetric potential
with a singularity at its origin.
The eigenstates show a clear angular momentum quantum number, the $\ell$-character. 
For usual atoms, bound states with $s$ ($\ell$ = 0), $p$ ($\ell$ = 1), $d$ ($\ell$ = 2) or even $f$ ($\ell$ = 3) character can be found.
Technically, the \ttt{radial\_eigensolver} module determines the solutions on a 1D radial grid.
Relativistic effects are treated on the basis of the scalar-relativistic approximation (SRA).
\todo[inline]{cite SRA}
Due to the spherical symmetry of the potential
the energies of core states are well defined
and degenerate with respect to the magnetic quantum number $m$.
Try
\begin{verbatim}
./a43 --test atom_core
\end{verbatim}
See Appendix \ref{sec:example-output-for-atom-core} for an example of the expected output.
%
%
\subsection{Treatment of Semicore States} \label{sec:semincore-states}
%
Semicore states are high-lying core states but energy-wise below the valence band.
Their wave function tail can extend beyond half a nearest neighbor atom distance.
In a tight-binding picture, the hopping matrix elements towards the neighboring atom are still small
but the non-sphericality of the potential becomes important.
The $m$-degeneracy of the energy (found for core states) breaks 
and crystal field splittings or even bands with a small dispersion can be observed.
\todo[inline]{Implement semicores}
\noindent
It is planned to implement semicore states with a separate energy window
and either a tight-binding like treatment derived from atomic orbitals 
(eigenfunctions of the spherically averaged potential) 
or with a full \ac{PAW} treatment as follows for the valence states.
Please stay tuned for feature updates.

%
%
\subsection{Treatment of Valence States} \label{sec:valence-states}
%
Valence states are high in energy, by definition up to the Fermi energy.
They are delocalized over several atoms and form bands and bonds.
Also, they are particularly difficult to describe because of the 
inhomgeneiety of features:
Valence states exhibit relatively slow oscillations 
in the space between atoms but close to the atomic nuclei,
their structure resembles that of high-lying core states.
In particular in projected radial coordinates, we can find up to $6$ nodes
(7$s$-bands) with the distances between nodes becoming smaller
the closer we move towards the core.
These rapid oscillations are difficult to represent
on the same footing that gets the behaviour in the interstitial regions correct. 
We will review some of the most common approaches:

\subsubsection*{Local orbital methods}
Local orbital methods use radial eigenfunctions 
of the spherically symmetric atomic potential (typically of neutral or selected ionized configurations) as atom-centered basis functions.
This captures the behaviour in the core region well
but shows a slow and not systematic convergence behaviour in the interstitial region. 
An advantage is that atomic orbital basis sets can be rather compact
and localized which casts the Hamiltonian into a block-sparse matrix operator with small block dimensions (up to $\approx 30$ basis functions per atom).
The drawback is that the description in the interstitial region determines the
quality of description for bandstructures, bonds and forces.
The advanced user may try
\begin{verbatim}
./a43 --test sho_hamiltonian
\end{verbatim}
see chapter \ref{sec:sho-hamiltonian} for details.

\subsubsection*{LAPW}
Linearized Augmented Plane Wave (LAPW) methods take the best of two worlds:
In order to construct efficient basis functions, 
they assume a spherical potential inside an atomic sphere (solutions are numerically given radial functions multiplied by spherical harmonics)
and a constant potential inside the interstitial region (solutions are plane waves). 
On the boundary spheres between the two regions, the basis function components need to be matched.
Due to the \ac{PW}-character, the basis functions are fully delocalized and 
the LAPW-Hamiltonian becomes a dense matrix.


\subsubsection*{Plane wave pseudopotential methods}
Using \ac{PW}s as a basis for the entire space shifts the problem to the representation of the valence wave function in the core region.
The \ac{PAW} method is a successful generalization of the family of pseudopotential methods which allows a full-potential and potentially an all-electron treatment.
A pseudopotential replaces the singular full $1/r$-potential in the core region
by a smooth potential which can be represented with a finite number of \ac{PW}s
and approximates the scattering properties (phase shifts) in the typical energy
range of valence states.
In most cases the construction of such a potential only succeeds in the form of a non-local potential, c.f.~chapter \ref{sec:single-atom}.
\\
Try the experimental feature
\begin{verbatim}
./a43 --test self_consistency +basis=plane_wave
\end{verbatim}
for moderate sized periodic geometries.

\subsubsection*{Real space grid methods}
Real-space grid based methods for \ac{DFT}
feature an improved scalability on massively parallel \ac{HPC} systems at the same level of accuracy as \ac{PW} basis sets. 
The \ac{PAW} method can be utilized and comes at the advantage that the projector functions are localized around the atoms, 
hence, the Hamiltonian becomes an implicit low-rank operator with sparsity which does not involve Fourier transforms when applied to a wave function.

\codename{} implements Cartesian real-space grids 
in combination with a revision of the \ac{PAW} method (revPAW) suitable for
a reduced memory capacity consumption and lower memory bandwidth requirements.
\todo[inline]{cite Baumeister, Tsukamoto, PASC19 proceedings}

















\section{Geometry Analysis Tool} \label{sec:geometry-analysis}
%
The geometry file (\ttt{+geometry.file=atoms.xyz}) is a file
holding three items:
the number of atoms $n\um{atoms}$, 
a comment line which specifies the rectangular cell parameters in \AA{}, 
and the atomic coordinates in \AA{} as
\begin{verbatim}
    2
    #cell 10.6 10.6 12.7 periodic periodic periodic
    Al   0 0 -1.05835
    P    0 0  1.05835
\end{verbatim}
It can be viewed by \ttt{Jmol}-viewer \cite{jmol-software}.
%
\noindent
To check if your coordinate file is parsed correctly run
\begin{verbatim}
./a43 --test geometry_analysis
\end{verbatim}
providing a rich log output about interatomic distances,
auto-detected bonds and atomic coordination numbers.
The following subsections explain the analysis results in more detail.

\subsection{Distance Histogram} \label{sec:distance-histogram}
%
At increased \ttt{verbosity} a distance histogram is generated with
a bin width of \ttt{+geometry\_analysis.bin.width} which is set to \unit[0.02]{\AA} by default.
The geometry analysis algorithm checks on every pair of atoms
including the effect of periodic images.
For geometries with many atoms in the simulation volume
a naive $\mathcal O(n\um{atoms}^2)$-algorithm 
leads to unaffordable compute requirements.
Hence, an $\mathcal O(n\um{atoms})$-algorithm has been implemented, see \cite{a43theory}.
For this, we define a maximum range $R$ controlled 
by \ttt{+geometry\_analysis.max.range} which is \unit[6.5]{\AA} by default.
The simulation cell is subdivided into rectangular boxes. 
Each box edge must be longer than $R$. 
The atoms are sorted into their corresponding boxes.
With this, atoms of each box must only check their distances 
with atoms of the adjacent $3^3$ boxes.
% \todo[inline]{Enrich the theory chapter about the theoretical crossover}
The range $R$ defines a natural upper end for the distance histogram.
A sparse representation of the distance histogram will be found in the log output.
This means that sequences longer than two bins where all entries are zero are not shown.
However, when plotted with solid lines, there is no difference, except much less zero data.
Search the log for \ttt{\#\# distance histogram} to find the legend:
The first column is the distance value of the bin in your chosen \ttt{+output.length.unit}.
The following columns represent all combinations of species.

\subsection{Bond Structure Analysis} \label{sec:bond-structure-analysis}
%
Find \ttt{\# bond structure analysis} in the log.
For particularly large systems, even one line per atom
can lead to very large log files which no human wants to read.
Therefore, statistical summaries 
for \ttt{\#\# bond angles} 
and \ttt{\#\# bond distances} are displayed at the end.
The per-atom output can be suppressed
by \ttt{+geometry\_analysis.show.bond.structure=0} or a low \ttt{+verbosity}.

\noindent
If the \ttt{bond structure analysis} is too memory consuming you may limit it to the first
\ttt{+geometry\_analysis.max.atoms.with.partners} atoms
or disable it entirely by \ttt{+geometry\_analysis.max.bond.partners=0},
however, summaries cannot be generated then.

\subsubsection{Bond Angles Histogram} \label{sec:bond-angle-histogram}
A histogram for \ttt{\#\# bond angles} is generated for each atomic species.
The bin width is 1\degree{} and the representation is sparse,
compare Section \ref{sec:distance-histogram}.

\subsubsection{Bond Distances Histogram} \label{sec:bond-distance-histogram}
A histogram for \ttt{\#\# bond distances} is generated for each atomic species.
The histogram parameters can be controlled by 
\ttt{+geometry\_analysis.bond.num.bins=184} and
\ttt{+geometry\_analysis.bond.bin.width} which defaults to $30$ bins/\AA{}.
The histogram representation is sparse, compare Section \ref{sec:distance-histogram}.
%% An example can be found here:
%% a43/doc/fig/Cu320Zr180_distance_hist.agr .pdf
\begin{figure}[t]
	\centering
	\includegraphics[width=.99\textwidth]{fig/Cu320Zr180_distance_hist}
	\label{fig:Cu320Zr180-distance-histogram}
	\caption{Atom-atom distance histogram and bond angle histogram for bulk Cu$_{320}$Zr$_{180}$. 
	         Atom distances are classified by the type pair (Cu--Cu, Cu--Zr and Zr--Zr)
	         and where counted as bond also as Cu bonds and Zr bonds.
	         Bond angles are only distinguished by the type of the central atom.}
\end{figure}



\subsection{Summaries}
%
Atom-atom bonds and distances are summarised after the potentially lengthy log output described in
sections \ref{sec:distance-histogram} and \ref{sec:bond-structure-analysis}.
% , \ref{sec:bond-angle-histogram} and \ref{sec:bond-distance-histogram}.

\noindent
A table of \ttt{coordination numbers} and their \ttt{occurrence} is given for each species.
The \ttt{\# half bond length} displays which radius has been taken to identify a bond.
The user may customize the half bond length, e.g.~for copper 
by setting \ttt{+geometry\_analysis.half.bond.Cu} in Bohr units.
The default bond length between two species is given by the sum of
the two \ttt{half bond length}s.
An interatomic distance below \ttt{+geometry\_analysis.elongation=1.25} 
times the default bond length is recognized as a bond
if the bond distance times the \ttt{elongation} also stays below the default bond length,
i.e.~by default bonds counted when they are within $80\%$ to $125\%$ of the default bond length.
%

\noindent
All \ttt{\# bond counts} are listed in an upper diagonal matrix as function of the two
contributing species. Row/column sums show the total number of bonds for a given species.
Further, the upper diagonal form is also used to display
\begin{itemize}
	\item the minimal distance
	\item the longest bond and
	\item the shortest bond
\end{itemize}
between to atoms of a given pair of species.
The \ttt{\# shortest bond} should coincide with \ttt{\# min. distance}
and shows \ttt{n/a} in case there is no bond.
The minimal distance is displayed as \ttt{n/a} if the atom-atom distance exceeds $R$.
%
The information of the four matrix tables described above
is also contained in the \ttt{\# bond table}.
Where bonds have been detected, 
the average and root-mean-square of the bond lengths are displayed
in addition to minimum and maximum.
The option \ttt{+geometry\_analysis.show.pairs=1} controls how much of the \ttt{bond table} is shown.
If the number of species in the system becomes large it might be helpful
to suppress the display of this table by setting it to \ttt{0}.
The default value \ttt{1} suppresses pairs that are unavailable (\ttt{n/a})
Setting it to \ttt{3} will show all entries and values \ttt{2} shows only
pairs that are near but not bonded.
These four options are particularly helpful for the synthetic input case discussed in Section \ref{sec:many-species-test}.

%
%
\subsection{Many Species Test} \label{sec:many-species-test}
%
To test the full functionality of the \ttt{geometry\_analysis},
we can generate a \ttt{+geometry\_analysis.test.file} 
with the default filename \ttt{species\_test.xyz}.
It contains \ttt{+geometry\_analysis.test.nspecies} $\in [2, 128]$ atoms, each with a
different species, positioned in a chain. Running
\begin{verbatim}
./a43 --test geometry_analysis +verbosity=7 \
        +geometry_analysis.select.test=-1 \
        +geometry_analysis.test.nspecies=4 \
        +geometry.file=species_test.xyz
\end{verbatim}
will create the file, parse it and analyze its linear geometry.
Technically, one could increase \ttt{+geometry\_analysis.test.nspecies} up to \ttt{127},
however, the output is far from readable due to too many too long lines.
The interatomic distances are chosen such that most coordination numbers
are $2$ and all bond angles are 180\degree{}.
%

\newpage

\section{Advanced Controls} \label{sec:advanced-controls}
%
This part of the \codename{} manual describes
various modules in detail.

%\subsection{Fermi level} \label{sec:fermi-level}
%During an \ac{SCF} calculation, 
%the Fermi energy can be determined in two different ways:
%\begin{itemize}
%	\item \ttt{exact}
%	\item \ttt{linearized} and
%	\item external
%\end{itemize}

\subsection{Atomic Core} \label{sec:atom-core}
%
\subsubsection{Self consistent potentials}
%
The \ttt{atom\_core} module determines self-consistent \ac{DFT} solutions
of a spherically symmetric, isolated atom with $Z$ protons in the core.
The resulting potential $V(r)$ is stored in \ttt{pot/Zeff.}$00Z$
in the form $-rV(r) = Z\um{eff}(r)$ given that the directory \ttt{./pot} has been created beforehand.
The files can be plotted by a simple tool like e.g.~\ttt{xmgrace pot/Zeff.013}.

\noindent
$Z\um{eff}(r)$ approaches $Z$ at the origin and goes to zero for large $r$.
To start an atomic all-electron calculation, e.g. for aluminum, run
\begin{verbatim}
./a43 --test atom_core +atom_core.test.Z=13
\end{verbatim}
If the \ttt{pot/Zeff.}$00Z$-file for more than one element are needed
the user can specify an exclusive upper end \ttt{+atom\_core.test.Z.end} 
and a step size \ttt{+atom\_core.test.Z.inc} which defaults to \ttt{1}.
A typical command line to generate files for all integer $Z$ is
\begin{verbatim}
./a43 -t atom_core +atom_core.test.Z=0 +atom_core.test.Z.end=121
\end{verbatim}
Beware that this might run for a minute or two.
Also non-integer values are permitted in all three parameters 
\ttt{+atom\_core.test.Z}, -\ttt{.Z.inc} and -\ttt{.Z.end}.
%

\noindent
For the atomic \ac{SCF} calculation, occupation numbers of the atomic orbitals are fixed
to predefined values. \ttt{atom\_core.occupations=auto} or \ttt{=custom} can be chosen
where they are taken from the element configuration, see Section \ref{sec:sigma-config}.
For an example output see the Appendix \ref{sec:example-output-for-atom-core}.

\subsubsection{Core State Diagrams} \label{sec:core-state-diagram}
visualize the energy and localization of core states. Try
\begin{verbatim}
./a43 -t atom_core +atom_core.show.state.diagram=5 > logg
\end{verbatim}
to plot a diagram representing the spherical all-electron potential $V\um{eff}(r)$
and the spherical states of copper by lines at their corresponding eigenenergies.
See figure \ref{fig:core-state-diagrams-Z30-and-Z80} for examples of zinc and mercury.
The lines start and end at the radii where $5\%$ and $95\%$ of the charge density of that state are included, respectively.
You can use \ttt{xmgrace -nxy logg} to plot the diagram.
\todo[inline]{check if state\_diagram.template.agr is checked into the git!}
\noindent
Mind that the radius has been transformed as $\sqrt{r}$
and the energies are shown as -$\log_{10}($-$E)$ to make up for the different scales involved.

\begin{figure}[h]
	\centering
	\includegraphics[width=.49\textwidth]{fig/state_diagram_Z30}
	\includegraphics[width=.49\textwidth]{fig/state_diagram_Z80}
	%% generated:
	%% ./a43 --test atom_core +atom_core.show.state.diagram=5 +atom_core.test.Z=30
	%% ./a43 --test atom_core +atom_core.show.state.diagram=5 +atom_core.test.Z=80
	\label{fig:core-state-diagrams-Z30-and-Z80}
	\caption{State diagrams generated by the \ttt{atom\_core} solver. 
	         Examples are zinc and mercury.
	         The square root radial axis and the logarithmic energy scale help to display
	         core and bound valence states in the same plot.
	         One can observe similarities in terms of energy and position between
	         the Zn 4$s$ and 4$p$ states with the Hg 6$s$ and 6$p$ states
	         (highest solid line in black and red, respectively). 
	         }
\end{figure}



\subsection{Element Configuration} \label{sec:sigma-config-short}
%
A list of $120$ default element configurations is contained in the application.
For example the default configuration for aluminum can be displayed by
\begin{verbatim}
./a43 --test sigma_config +sigma_config.test.Z=13
\end{verbatim}
The user can modify the configuration string using the chemical symbol
\begin{verbatim}
./a43 --test sigma_config +sigma_config.test.Z=13 \
	        +element_Al="3s* 2 3p 1 | 2.05 sigma .5" 		
\end{verbatim}
where the high quotes are necessary only in the command line interface
and can be omitted in the control file, see Section \ref{sec:control-file-rules}.
%
\noindent
An element configuration string consists of
\begin{itemize}
	\item valence occupations used for the isolated atom calculation, here $3s^2 \, 3p^1$
	\item a \ac{PAW} cutoff radius after the \ttt{|}, here $2.05\,$Bohr
	\item a \ttt{sigma} parameter for the spread of \ac{SHO} projectors, here $0.5\,$Bohr
	\item additional partial waves, here \ttt{s*}, i.e.~a second $s$-wave.
\end{itemize}

\subsection{PAW Potential Generation} \label{sec:single-atom}
%
When modifying the element configurations for \ac{PAW} generation,
we recommend to inspect the logarithmic derivatives by
\begin{verbatim}
./a43 --test single_atom +single_atom.test.Z=13 \
        +logder.start=-4 +logder.step=1e-4 +logder.stop=1
\end{verbatim}
The output can be visualized by \ttt{gnuplot} or \ttt{xmgrace -nxy} $logfile$.
%
\noindent
For the ease of use, we may add \ttt{+logder.unit=eV} and then specify
\ttt{logder.start}, \ttt{logder.stop} and \ttt{logder.step} in units of \ttt{eV}.

\noindent
Logarithmic derivatives are summarized by the position of the resonances (poles).
At \ttt{+verbosity=8} or higher the generalized node counts are given plottable in the log file.

\noindent
The \ttt{eigenstate\_analysis} tool solves the spherically symmetric pseudo atom
problem on an equidistant radial mesh. This allows to check for ghost states of the pseudopotential.
Increase \ttt{+scattering\_test.eigenstate.analysis.warn=.005} (5 mHa) to suppress warnings about deviations.
To check correct functionality, run
\begin{verbatim}
./a43 --test scattering_test
\end{verbatim}
on the analytically solvable problem of the \ac{SHO}.
You can verify that the deviation from pure half-integer energies is small.

\noindent
\ttt{./a43 --test single\_atom} produces a lot of output (more than 100 lines).
As a first approach look out for warnings.
In further steps, increase the verbosity level slightly (\ttt{-v}) and read the details about partial wave generation schemes that have been applied to generate the \ac{PAW} potential.

\subsubsection{Exporting PAW potentials} \label{sec:single-atom-export}
%
The \ac{PAW} data generated by \ttt{single\_atom} can be exported into the \ttt{PAW-XML} format defined
by CECAM's ESL\cite{CECAM_Electronic_Structure_Library} (https://esl.cecam.org/data/paw-xml/)
to later be imported by GPAW\cite{gpaw} and ABINIT\cite{abinit}.
To export please add \ttt{+single\_atom.export=1} and \ttt{+single\_atom.smooth.radial.grid.from=0}.
The latter option is necessary as \ttt{single\_atom} by default uses less grid points close to the radial center 
to represent smooth quantities compared to all-electron quantities, 
however, it may be better to use a single radial grid in the \ttt{PAW-XML} file
although the standard says that multiple radial grids should be supported.
In case it is necessary to explicitly include the values of the radial grid in the file add 
\ttt{+pawxml\_export.show.radial.grid=1}.

\noindent
The \ttt{single\_atom} module starts the all-electron radial grid at zero.
If that is a problem for the importing software package increase \ttt{+pawxml\_export.radial.grid.from} to \ttt{1} or higher. File names are generated as \ttt{Cu.xml} for copper. \\
A path \ttt{+pawxml\_export.path="."} may be adjusted by the user. 

\noindent
Mind that the \ttt{UPF} format supported by Quantum Espresso\cite{qe} is currently not fully supported.
Try \ttt{+pawxml\_export.type=upf} to see how much is working so far.

\noindent
\codename{} natively uses a radial exponential grid with the equation \ttt{r=a*(exp(d*i)-1)}.
If this cannot be imported by the other software, try \ttt{+single\_atom.radial.grid.equation=reciprocal} for GPAW's native radial grid.

\noindent
Within the development branch of \codename{}, several experimental ways to generate the smooth partial waves
are implemented. ABINIT, however, checks very strictly that smooth and true partial wave coincide outside the augmentation sphere. Therefore, \ttt{+single\_atom.partial.wave.method=classical} is currently the only option that produces PAW-XML files that can be run by ABINIT.


\subsection{LibLiveAtom} \label{sec:lib-live-atom}
%
The functionality of the \ttt{single\_atom} module to generate \ac{PAW} potentials from a configuration string and a radial potential file \ttt{pot/Zeff.}$00Z$ can be used by other \ac{DFT} codes.
Therefore, the shared object library \ttt{libliveatom.so} is built during compilation and examples of its \ac{API} can be found in the subfolder \ttt{interfaces/} for \ttt{C}, \ttt{F90}, \ttt{Julia} and \ttt{Python}.
Mind that there is not export functionality foreseen for the radial function of projectors as by default the projector functions are pure Cartesian \ac{SHO} functions, so that only \ttt{sigma} and \ttt{numax} need to be communicated.

\subsection{Self Consistency Iterations} \label{sec:self-consistency}
%
At the heart of every \ac{DFT} code are the \ac{SCF} iterations.
\begin{verbatim}
./a43 --test self_consistency
\end{verbatim}
takes several control variables, the most important ones are listed in Table \ref{tab:main-scf-variables}.
We recommend to store them in a \ttt{+control.file}, see Section \ref{sec:control-file}.
%
\begin{table}[h]
\caption[Main Variables]{
Most important variables to control self-consistency iterations in \codename{}.
} \label{tab:main-scf-variables}
\centering
\begin{tabular}{|l|r|l|}
\hline
  Variable Name & Default & Meaning, \ttt{Alternatives} \\
\hline
  \ttt{geometry.file} & \ttt{atoms.xyz}   & Atomic coordinates and cell file \\
  \ttt{basis}         & \ttt{grid}        & Basis set, \ttt{plane\_wave}, \ttt{sho} \\ 
  \ttt{grid.spacing}  & \unit[0.125]{\AA} & Coarse real-space grid spacing \\
  \ttt{grid.eigensolver} & \ttt{CG}       & \ttt{Davidson}, \ttt{explicit}, \ttt{none} \\
  \ttt{plane\_wave.solver} & \ttt{auto}   & \ttt{direct}, \ttt{iterative}, \ttt{both} \\ 
  \ttt{plane\_wave.cutoff.energy} & \unit[11]{Ha} & Plane wave cutoff energy \\
  \ttt{check}         & \ttt{0}           & Dry run, \ttt{1}: preparations only \\
  \ttt{valence.electrons} & \ttt{auto}    & Total number of valence electrons \\
  \ttt{initial.valence.density} & \ttt{atomic} & Start density, \ttt{load}, \ttt{none} \\
  \ttt{hamiltonian.kmesh} & \ttt{1}       & Brillouin zone integration points \\
  \ttt{electrostatic.solver} & \ttt{fft}  & Coulomb solver, \ttt{multi\_grid}, \ttt{none} \\
  \ttt{bands.per.atom} & $10$ 			  & Number of eigenstates per atom \\
  \ttt{electronic.temperature} & \unit[315.8]{K} & Electronic smearing temperature \\
  \ttt{fermi.level}   & \ttt{exact}       & Fermi level method, \ttt{linearized} \\
  \ttt{self\_consistency.mix.density} & $0.25$ & Simple density mixing parameter \\
  \ttt{self\_consistency.max.scf} & $1$   & Max.~number of \ac{SCF} iterations \\
  \ttt{start.waves}   &                   & Load wave functions from this file \\
  \ttt{store.waves}   &                   & Store wave functions to this file \\
\hline
\end{tabular}
\end{table}
%
\todo[inline]{implement \ttt{store.density} and \ttt{load.density} from file}

\noindent
See the accompanying script \ttt{test/self\_consistency.test.sh} as a usage example.

\subsection{Brillouin Zone Integration} \label{sec:brillouin-zone}
%
A uniform $\vec k$-point mesh is implemented in \codename{}.
Use \ttt{+hamiltonian.kmesh} with values larger than \ttt{1} to
specify an isotropic integer value or use
\ttt{+hamiltonian.kmesh.x}, -\ttt{.y} and -\ttt{.z} 
to control each spatial direction separately.
If more than $2$ points are used to sample any direction,
wave functions cannot be real-valued due to complex phase factors.
%
%

\subsection{Element Configuration} \label{sec:sigma-config}
%
The configuration of chemical elements contains various parts:
\begin{itemize}
  \item Occupation numbers for spherical calculations
  \item Orbital classification into \ttt{core}, \ttt{semicore} and \ttt{valence}
  \item \ac{PAW} generation parameters
\end{itemize}
%
\noindent
The configuration string for the details of the \ac{PAW} data set should be 
specified in each input file to make sure the results are the same. Run
\begin{verbatim}
./a43 --test sigma_config -v
\end{verbatim}
to check that all default configuration strings can be parsed without errors.
\\
To check only e.g.~strontium and show its configuration run
\begin{verbatim}
./a43 --test sigma_config +sigma_config.test.Z=38
\end{verbatim}
The configuration string can be specified as
\begin{verbatim}
+element_Sr=4s 2 5s 2 4p* 6 4d | 2.37 sigma .666
\end{verbatim}
in the \ttt{+control.file} or via the command line as
\begin{verbatim}
./a43 --test sigma_config +sigma_config.test.Z=38 \
        +element_Sr="4s 2 5s 2 4p* 6 4d | 2.37 sigma .666"
\end{verbatim}
The variable name \ttt{+element\_}$Sy$ expects an element symbol $Sy$ 
like \ttt{Sr} for strontium or \ttt{S} for sulfur, case-sensitive, no blank between keyword and \ttt{=} sign.
In the electronic configuration string the orbital specifier \ttt{4s} sets the 4$s$-state to be 
included in the set of valence states. Automatically, 1$s$, 2$s$ and 3$s$ are set to 
be \ttt{core} states.
The \ttt{2} following \ttt{4s} represents an occupation number
and is, hence, interpreted as floating point number \ttt{2.0}.
It is used for the all-electron self-consistent isolated atom calculation in \ttt{atom\_core}, see Section \ref{sec:atom-core}
and for the relaxation of the atomic \ttt{core} and \ttt{semicore} states in \ttt{single\_atom}.
If no occupation number is given, the occupation is zero, if a single number is given,
both spin-channels are given half of the occupation and with two numbers
we define a magnetization, i.e.~majority and minority spin.

\noindent
Semicore state can be marked e.g.~by \ttt{4sSemicore 2}.
Similarly, core holes can be introduced by modifying the occupation numbers of
a \ttt{core} orbital, e.g.~\ttt{1sCore 1 0}.
Mind that previous versions of the parser supported e.g.~\ttt{3phole}
to specify how many electrons to subtract from the $3p$ core state occupation.
This is not supported any longer and aborts in an error.

\noindent
A second valence orbitals with the same angular momentum $\ell$ as in \ttt{+element\_Sr=4s 2 5s 2} [...] 
effects that two partial waves are used for this $\ell$. In this particular case, both valence states are occupied.
Additional partial waves can be added by asterisks as e.g.~in \ttt{+element\_Os=6s* 2} [...].
Note that \ttt{+element\_Sr=4s 2 5s*} [...] or \ttt{+element\_Sr=4s* 2 5s} [...] %% ToDo: check this
would activate a third set of partial waves and projectors which is not recommended for reasons of stability.
The example of Osmium shows how the \ac{PAW} augmentation radius is specified after the vertical bar \ttt{|}.
Furthermore, the $\sigma$-spread of \ac{SHO}-projectors can be specified using the keyword \ttt{sigma}.
The radius and spread are always given in \ttt{Bohr} atomic units!
\todo[inline]{Work on magnetism}
\noindent
When a magnetization is induced in the occupation numbers,
please make sure that the first number is the majority spin as e.g.~\ttt{5d* 5 1}.
Mind that currently only spin-paired atomic all-electron calculation can be performed by \ttt{atom\_core}.
%
To control the potential pseudization in the \ac{PAW} method we can insert 
\ttt{V=sinc} or \ttt{V=parabola} at the end of the configuration string, no blank after \ttt{=}.
The advanced user can specify \ttt{numax} ($\nu\um{max}$) to manipulate the size of the \ac{SHO}-projector basis
and adjust the number of protons \ttt{Zcore} ($Z$), even to non-integer values.
%
%
%

\subsection{Automatic Element Config} \label{sec:element-config}
%
Mind that this is an experimental alternative to \ttt{sigma\_config} 
introduced in Section \ref{sec:sigma-config}.
Ensure that the \ttt{-D DEVEL} preprocessor flags is active and
\ttt{HAS\_ELEMENT\_CONFIG} is defined in \ttt{single\_atom.cxx}.
Use \ttt{+single\_atom.config=element} to activate it.
Control keywords are given in Table \ref{tab:element-config-variables}.
%
\begin{table}[h]
\caption[Element Config Variables]{
Control variables for \ttt{element\_config}
} \label{tab:element-config-variables}
\centering
\begin{tabular}{|r|l|l|r|}
\hline
  \# & Variable & Meaning & Default \\
\hline
 a) & \ttt{element\_}$Sy$\ttt{.rcut}         & \ac{PAW} augmentation radius in Bohr         & see h) \\
 b) & \ttt{element\_}$Sy$\ttt{.sigma}        & \ac{SHO} projector spread in Bohr            & see i) \\
 c) & \ttt{element\_}$Sy$\ttt{.numax}        & integer \ac{SHO} basis size                  & see j) \\
 d) & \ttt{element\_}$Sy$\ttt{.method}       & potential pseudization method                & see k) \\
 e) & \ttt{element\_}$Sy$\ttt{.hole.enn}     & core hole $n$                                & 0 \\
 f) & \ttt{element\_}$Sy$\ttt{.hole.ell}     & core hole $\ell$                             & -1 \\
 g) & \ttt{element\_}$Sy$\ttt{.hole.charge}  & core hole charge                             & 0.0 \\
 h) & \ttt{element\_config.rcut}             & Default for \ttt{element\_}$Sy$\ttt{.rcut}   & \unit[2.0]{Bohr} \\
 i) & \ttt{element\_config.sigma}            & Default for \ttt{element\_}$Sy$\ttt{.sigma}  & \unit[0.5]{Bohr} \\
 j) & \ttt{element\_config.numax}            & Default for \ttt{element\_}$Sy$\ttt{.numax}  & 3 \\
 k) & \ttt{element\_config.method}           & Default for \ttt{element\_}$Sy$\ttt{.method} & \ttt{sinc} \\
 l) & \ttt{element\_config.core.valence}     & Energy between core and valence bands        & \unit[-2.0]{Ha} \\
 m) & \ttt{element\_config.core.semicore}    & Energy between core and semicore bands       & see l) \\
 n) & \ttt{element\_config.semicore.valence} & Energy between semicore and valence bands    & see l) \\
\hline
\end{tabular}
\end{table}
%
If \ttt{+single\_atom.core.state.localization} is not a positive number
an energy criterion is used to distinguish \ttt{core}, \ttt{semicore} and \ttt{valence} states, see l), m) and n) in Table \ref{tab:element-config-variables}.












\cleardoublepage
\newpage

\section{The Real-Space Green function DFT method} \label{sec:green}

\subsection{Theory}
In wave function methods the electron density is found as sum over the absolute square of occupied wave functions, see Eq.~(\ref{eqn:simplified_density_generation}).
Mathematically, we can also find the electron density integrating over an energy contour over the imaginary part of the trace of the green function, i.e.
\begin{align}
  \int\limits_{\mathcal C} \mathrm{d}E \, \Im\{ G(\vec r, \vec r; E) \} &= \varrho(\vec r) \\
  \left( \hat H - E \cdot \hat S \right) \cdot \hat G &= \mathbf{1}
\end{align}
There are two striking advantages of a Green function formulation.
First, matrix inversions or linear system solves are needed rather than eigenvalue problems.
This allows for an efficient parallelization over right-hand-sides.
Second, Green function elements relating distance parts of space can be truncated which allows for a linear scaling method.

\subsection{Code}
The second important executable shipped with the \fullcodename{} package is \ttt{./green}
with the purpose of finding the Green function of the implicit real-space Hamiltonian. Running
\begin{verbatim}
./green --help
\end{verbatim}
will look very similar to \ttt{./a43 -h}, however, \ttt{./green} is an \ac{MPI} application
with CUDA support so you might want to start it in a parallel environment, e.g.~\ttt{srun -n1} for SLURM,
and (if available) on a compute system with CUDA-capable \ac{GPU}s.

%
\begin{table}[h]
\caption[Main Variables]{
Most important variables to control the Green function calculation.
} \label{tab:main-green-variables}
\centering
\begin{tabular}{|l|r|l|}
\hline
  Variable Name & Default & Meaning \\
\hline
  \ttt{green\_function.truncation.radius} & $10\,$Bohr   & Green function truncation radius \\
  \ttt{green\_function.projection.radius} & $6$          & Radius of non-local potential, in units of $\sigma$ \\
  \ttt{green\_function.sources}			  & 1            & Number of \ac{RHS} blocks, \ttt{-1}: all \\
  \ttt{tfqmrgpu.max.iterations}           & $99$         & Iterative solver limit \\
\hline
\end{tabular}
\end{table}
%
\noindent
Table \ref{tab:main-green-variables} gives an overview of the most important control variables.
\todo[inline]{Augment the table}

\noindent
% grep -in 'hamiltonian\.file' ../green/*.cxx ../include/*.hxx
The \ac{DFT} Hamiltonian $\hat H$ is passed to \ttt{./green} via an \ac{XML} or a \ttt{JSON} formatted file.
The filename is controlled by \ttt{+hamiltonian.file} with default name \ttt{Hmt.xml}.

\subsection{Getting started} \label{sec:green-getting-started}
%
\begin{verbatim}
./green --test '?'
\end{verbatim}
will list all available module tests. Many of these modules are shared with \ttt{./a43}.
Start by
\begin{verbatim}
./green --test green_input
\end{verbatim}
to see if the input file \ttt{+hamiltonian.file=Hmt.xml} is found and parsed without errors or warnings.

%
\noindent
Proceed by benchmarking the action of the implicit Hamiltonian:
\begin{verbatim}
./green --test green_function +green_function.benchmark.action=0
\end{verbatim}
First, we add \ttt{+green\_function.benchmark.action=0} to check if the Green function construction process runs error-free.
Then, we can control 
\begin{verbatim}
./green --test green_function +green_function.benchmark.iterations=0
\end{verbatim}
to first see if the \ttt{action\_t} can be constructed properly.
Next, we run a single iteration of the action alone by \ttt{+green\_function.benchmark.iterations=-1}.
If that works, we can run many (e.g.~$10$) iterations and check performance numbers and their variance.
Set \ttt{+green\_function.benchmark.iterations=-10} for that.
\noindent
Finally, if that works we can start the solver setup with 
\begin{verbatim}
./green --test green_function +green_function.benchmark.iterations=1 \
			   +tfqmrgpu.max.iterations=0
\end{verbatim}
and on success increase \ttt{iterations} to \ttt{1}, \ttt{10}, and more.

%
\noindent
The default precision type is \ttt{+green\_function.benchmark.floating.point.bits=32}, i.e.~\ttt{float}.
If the memory capacity of the \ac{GPU} allows, we can increase to \ttt{=64} for \ttt{double}.
Further, we can try to run the experimental feature for non-collinear magnetism by \ttt{+green\_function.benchmark.noco=2}.

%
\noindent
\emph{Real/Complex} If \ttt{./green} has been built without the \ttt{tfQMRgpu} library,
we can also check the performance of the action alone for real numbers by \ttt{+green\_function.benchmark.complex=0} while the default is \ttt{=1}.

\subsection{Green experiments} \label{sec:green-experiments}
The module \ttt{green\_experiments} is designed to verify that the \ac{DFT} Hamiltonian loaded from file
is implemented equivalent to where the file was written.
It works best if we still have the logg files from the generation process of the \ttt{Hmt.xml} file 
and if we have diagonalized the Hamiltonian at various $\vec{k}$-points or on a $\vec{k}$-path to compare to.
The two different ways implemented to find the spectrum are
\begin{itemize}
  \item by inversion,
  \item by diagonalization.
\end{itemize}
In the inversion approach, the Green function is found by \ttt{tfQMRgpu} at various $\vec{k}$-points
and a very dense set of energy parameters $E$ with a constant imaginary part.
The result is a heatmap on the strength of the resonance, 
i.e.~the integrated trace of the imaginary part of the found Green function.\\
For the diagonalization approach the \ttt{action\_t} which usually represents $\hat A = \hat H - E\cdot \hat S$ is duplicated into $\hat H = 1\cdot \hat H - 0\cdot\hat S$ and $\hat S = 0\cdot \hat H - (-1)\cdot\hat S$.
Both operators, $\hat H$ and $\hat S$, enter an iterative Davidson diagonalization procedure. For small grids (up to $12 \times 12 \times 12$ points on the coarse grid) a dense matrix diagonalization routine can be called instead to find the exact spectrum directly.
\begin{verbatim}
./green --test green_experiments
\end{verbatim}

\subsection{Parallel SCF Runs}
The main module for \ac{MPI}-parallelized \ac{SCF} runs is \ttt{parallel\_potential}.
It works very similar to \ttt{self\_consistency}, however, the only available Poisson solver
is a conjugate gradients method (\ttt{poisson.method=cg}) with an \ac{MPI}-parallelized 16th-order finite difference Laplacian stencil.
Internally, densities and potentials are treated on the dense grid, i.e.~$8 \times 8 \times 8$ grid points form a block and the FD-stencil has a range of one block towards each of the six Cartesian directions.
Before the parallelized electronic structure solver \ttt{green\_solver} is called, the effective potential is
reduced to the coarse grid by averaging over eight adjacent grid points to generate blocks of $4 \times 4 \times 4$ grid points. Similarly, the new density is interpolated in a tri-linear fashion to blocks of $8 \times 8 \times 8$ after the solver. Details of the solver are discussed in the following section.

\newpage

\section{Parallel Electronic Structure Solver}
Different from most conventional \ac{DFT} codes
the new density is computed from a given potential using the Green function method,
i.e.~the new density is not given by a summation over bands over the absolute square of wave functions,
but it is a energy contour integration over the imaginary part of the diagonal of the Green function.

\subsection{Energy Contour Integration}
Since a \ac{DFT}-Hamiltonian is Hermitian by construction, its eigenvalue spectrum lies on the real axis.
The energy contour integration is a mathematically elegant way to avoid an integration over singular values
which would occur if we tried to integrate
\begin{equation}
	\int\limits_{-\infty}^{E\um{Fermi}} \ \mathrm d E (\hat H - E \hat S)^{-1}
\end{equation}
since $(\hat H - E \hat S)$ diverges when $E$ comes close to a generalized real-valued eigenvalue.
The method foresees a contour path around the problematic regions on the real axis
which leads to a set of energy points with a nonzero imaginary part and corresponding complex weights.
The KKR multiple scattering Green function methods have explored this method. 
\todo{References needed}.
At each energy point, the diagonal elements of the Green function $\hat G(E) = (\hat H - E \hat S)^{-1}$ need to be found.

\noindent
In addition to that boundary conditions may require an additional integration in reciprocal space ($\vec k$-points)
where the number of sampling points of the Brillouin zone may be chosen larger, the closer $E$ is to the Fermi level (not yet implemented).
Each $(E,\vec k)$-point can be solved independently of each other and therefore is a potential degree of parallelism which is so far not exploited due to the expected difficult load balancing of these tasks. The following subsection will shine some lights on why imbalances in the runtime are to be expected.

\todo{insert typical path SVG picture}

\subsection{Green Solver}
The heart of the \fullcodename{} code is the \ac{MPI}-parallelized Green function solver,
implemented in the comparably shallow wrapper module \ttt{green\_solver}, 
the central module \ttt{green\_action} making use of the header-only \ttt{tfQMRgpu} library \cite{tfQMRgpu-preprint}
which accepts an action operator $\hat A_{\vec k}(E) := (\hat H_{\vec k} - E\hat S_{\vec k})$, henceforth abbreviated simply $\hat A$.
The transpose-free Quasi Minimal Residual method (tfQMR) solves the linear problem $\hat A \cdot \hat X = \hat B$ where in our case $\hat X \equiv \hat G$ is the Green function and the right hand sides $\hat B \equiv \mathbf{1}$ are a unit matrix.

\noindent
The preparation modules \ttt{green\_function}, \ttt{kinetic\_plan} and \ttt{dyadic\_plan} offer methods create data structures that allow the action $\hat A$ to be applied to a selected set of columns of the overall Green function $\hat G(\vec r, \vec r')$ where also for $\hat G$ the index pair $(E,\vec k)$ is suppressed for clarity of the notation.
The columns are distributed over all \ac{MPI} processes so that at the end of a solver run, a Green function element for each $\vec r'$ of the entire simulation grid has been calculated.
To allow efficient bookkeeping, we group $4 \times 4 \times 4$ grid points together to form a so-called \emph{cube}.
It may differ from a real cube in space if the (Cartesian) grid spacings are anisotropic.
Furthermore, we allow several (currently up to $2^{16}=65536$) cubes to be processed by each \ac{MPI} rank.

The prepared data structures help to compute the product $\hat A \cdot \hat G\um{trial}$ which does not return a unit operator until the iterative solver has converged. The multiplication routines are making extensive use of sparsity of both, $\hat A$ and $\hat G$. Sparsity of $\hat G$ arises from truncation: Green function elements are not considered if 
\begin{equation}
	G(\vec r,\vec r') = 0 \  \text{for} \  |\vec r - \vec r'| > R\um{trunc}
\end{equation}
Also here, grouping of $4 \times 4 \times 4$ grid points $\vec r$ leads to a block-sparsity of $\hat G$ with a block size of $64 \times 64$.

Furthermore, $\hat A$ inherits sparsity from $\hat H$ and $\hat S$:
\begin{equation}
	\hat A := \hat T\um{FD} + \left(V\um{eff}(\vec r) - E\right) + \sum_{aij} \braketop{\tilde p^{[a]}_i}{(h^{[a]}_{ij} - E\ s^{[a]}_{ij})}{\tilde p^{[a]}_j}
\end{equation}
The finite-difference approximated kinetic energy operator ($\hat T\um{FD}$) contained in $\hat H$ has a sparse matrix representation
that can be described by its stencil. Stencils with $8\cdot 6 + 1 = 49$ points and $25$ points are implemented in \ttt{green\_kinetic} for isolated and periodic boundary conditions, respectively.
Due to the real-space representation the local effective potential operator reduces to a mere multiplication with $V\um{eff}(\vec r)$, see \ttt{green\_potential}.
Depending on the atomic geometry and projector radii the \ac{PAW}-pseudized Hamiltonian $H(\vec r,\vec r')$ and its overlap operator may not be sparse in the sense of zeros in a dense matrix representation,
however, the combined dyadic parts of $\hat H - E\hat S$ are implemented in a low-rank update scheme (c.f.~\ttt{green\_dyadic}) while exploiting sparsity arising from the localization of atomic \ac{PAW} projector functions $\tilde p$.

\noindent
The iterative solver algorithm implemented in \ttt{tfQMRgpu} may differ significantly in terms of the number of iterations needed to converge all column residuals below a given threshold. Iteration counts will be larger the closer an energy point $E$ is to eigen-energies on the real axis. For a metallic system, energy points at the Fermi level are expected to exhibit very large iteration counts as the condition number of $\hat A$ is high. Metallicity, however, can occur as a localized phenomenon which could be reflected in imbalance between \ac{MPI} ranks solving for different parts of space.
Furthermore, imbalance between $\vec k$-points is expected, in particular close to the Fermi surface.


\subsection{Memory Requirements}
The iterative solving method $tfQMR$ requires to hold eight to ten fields of the size of $X$ in memory. Let's assume $10$ fields to make up for unaccounted overheads.
As $X$ represents the block-sparse Green function, the main \ac{GPU} memory consumption per grid point ($mem\um{total}$) for a large simulation volume hence depends mostly on the truncation radius $R\um{trunc}$ in units of the grid spacing $h$
\begin{equation} 
	mem\um{total} = 10 \cdot \frac{4\pi}{3}(R\um{trunc}/h)^3 \cdot \unit[16]{Byte}
\end{equation}
assuming double precision complex numbers.
For small simulation volumes ($V\um{cell} \ll R\um{trunc}^3$) the total memory consumption is quadratic in the number of grid points. In the transition region between small and large volumes the curve depends on the chose boundary conditions, c.f.~Fig..ToDo

\todo{measure Green function memory as a function of size}

\newpage
%

\section{Experimental features}
This chapter treats features that still lack rigorous testing and could benefit from improvements.

\subsection{Pseudo-atomic-orbital-basis}
Much cheaper than the Cartesian real space grid representation of wave functions or Green functions
are compact basis sets of pseudo atomic orbitals.
In fact, we select a set of valence orbitals, e.g.~the set selected for \ac{PAW} generation,
and diagonalize the Hamiltonian in these.
The basis sets are defined in the file \ttt{pseudo\_basis.xml}, formatted in \ac{XML}.
Instead of a Gaussian $\alpha$ spread, there is a \ttt{numax} and \ttt{sigma} parameter attached to each \ttt{<set>} which becomes clear from the next section.

\subsection{SHO-as-a-basis} \label{sec:sho-hamiltonian}
To compute the matrix elements of Hamiltonian and overlap operator expanded in a pseudo atomic orbitals,
we expand the radial functions of the pseudo atomic orbitals into radial eigenfunctions of the \ac{SHO}.
This requires a certain cutoff $\nu\um{max}$ given as \ttt{numax} in \ttt{pseudo\_basis.xml}.
The module \ttt{sho\_basis} provides the transformation matrix from a Cartesian \ac{SHO} basis set
to the selected pseudo atomic orbitals. 

It is fairly straightforward to compute kinetic energy elements for Cartesian products of \ac{HO} functions
as these functions are given analytically.
Since a Gaussian at one center multiplied by a Gaussian at a different center leads to another Gaussian
centered at a location between the two original centers, it is simple to compute overlap integrals between \ac{SHO} basis
functions on two atoms, c.f.~\ttt{sho\_overlap}.
The same is exploited for the evaluation of the inner products of basis functions and \ac{PAW} projectors
since also the \ac{PAW} projectors are given in a Cartesian \ac{SHO} basis.

Slightly more complicated is the evaluation of the local potential matrix elements.
Here, various methods have been tried, see \ttt{sho\_potential}.

Once the elements of the \ttt{sho\_hamiltonian} and overlap matrix are given in the \ac{SHO} basis
we can apply a transformation matrix from left and right that is generated from the expansion
coefficients of the radial basis functions in radial \ac{SHO} eigenstates.
This transformation matrix also incorporates the \ttt{sho\_transform} from Cartesian to radial
representations which preserves sharp $(\ell,m)$ quantum numbers for the basis functions.

\begin{verbatim}
./a43 -t sho_hamiltonian +sho_hamiltonian.use.sho_basis=yes
\end{verbatim}

\noindent
Furthermore, the size of the used \ac{SHO} basis can be controlled via \ttt{+sho\_hamiltonian.test.numax=-1},
where \ttt{-1} means use the smallest \ac{SHO} expansion of the basis set available in \ttt{pseudo\_basis.xml}, or
individually for different species, e.g.~via \ttt{sho\_basis.Cu.numax=-1} for copper.

\subsection{Generation of pseudo atomic orbitals}
In order to generate sets of pseudo atomic orbitals, e.g.~for copper, we pseudize an atom according to the \ac{PAW} recipes, see chapter \ref{sec:single-atom} on the \ttt{single\_atom} module.
Additionally, we add the following \ttt{fit.basis} parameters:
\begin{verbatim}
./a43 -t single_atom +single_atom.test.Z=29 \
        +single_atom.fit.basis.numax=19 \
        +single_atom.fit.basis.sigma=1.5 \
        +single_atom.fit.basis.weight=.0 
\end{verbatim}
The fitting procedure runs for all possible $\nu\um{max}$ up to \ttt{fit.basis.numax}
where the minimum \ttt{numax} is determined by the configuration of partial waves, see element configuration in chapter \ref{sec:element-config}. 
It searches for an optimal \ac{SHO} spread $\sigma$ where \ttt{fit.basis.sigma} is used as a start guess and to define the search boundaries.

The optimization finds a single value of $\sigma$ for all basis functions at the same time.
The smooth partial waves (pseudo wave functions) are expanded in radial \ac{SHO} eigenstates.
Since the occupied valence wave functions are typically most important for ground state results,
the optimization weights are the orbital occupation numbers by default 
(for \ttt{Cu} $4s_{2} \, 3d_{9}$ or $4s_{1} \, 3d_{10}$, see \ttt{sigma\_config}).
However, we can specify additional \ttt{weight} to all states.

The newly generated file is called \ttt{pseudo\_basis.29.xml} containing expansion coefficients of
the radial basis functions. Its content can be copy-pasted into \ttt{pseudo\_basis.xml}
or, if only copper atoms are in the sample, \ttt{+sho\_basis.file} can be set to \ttt{psuedo\_basis.29.xml}.

\newpage

\appendix
%
\section{Appendix}
%
\subsection{Example output for \ttt{atom\_core}} \label{sec:example-output-for-atom-core}
% %%% ./a43 -t atom_core +output.energy.unit=eV
\small
\begin{verbatim}
# ../src/a43 -t atom_core +output.energy.unit=eV
# no control file given
# ../src/a43 git checkout 54f7de72061aca6983604646dff204d9e497d5b2

# verbosity=3

# run unit tests for module 'atom_core'

# test_initial_density: max. deviation of 1.67582e-05 electrons

# atom_core.cxx:689  test_core_solver(echo=3) from 29 to 29 in steps of 1

# atom_core solver for Z= 29
# Warning: For Z=29 the occupation of the 4s-orbital differs: 1 vs 2 (auto)
# Warning: For Z=29 the occupation of the 3d-orbital differs: 10 vs 9 (auto)

# scf_atom  Z=29  converged in 4 iterations to residual=8.6e-12, E_tot= -44950.227271587 eV
# scf_atom  Z=29  E_kin= 45580.040948985 E_xc= -1765.741427975 E_es= -88764.526792597 eV
# scf_atom  Z=29  E_Coulomb= -108290.697652190 E_Hartree= 19526.170859594 eV
# scf_atom  Z=29  1s  E=   -8830.171213 eV  f=2
# scf_atom  Z=29  2s  E=   -1059.896506 eV  f=2
# scf_atom  Z=29  2p  E=    -916.335599 eV  f=6
# scf_atom  Z=29  3s  E=    -114.063277 eV  f=2
# scf_atom  Z=29  3p  E=     -72.008914 eV  f=6
# scf_atom  Z=29  4s  E=      -4.846013 eV  f=1
# scf_atom  Z=29  3d  E=      -5.316783 eV  f=10
# scf_atom  Z=29  4p  E=      -0.660459 eV  f=2e-99

#    module= atom_core                status= 0

#
# recorded 1 different warnings:
# 	in atom_core.cxx:237 scf_atom (2 times)
# 		For Z=29 the occupation of the 3d-orbital differs: 10 vs 9 (auto)
# 2 warnings in total
\end{verbatim}
\normalsize
%
\noindent
There is a warning here: the \ttt{auto}-matic configuration of atomic occupation numbers
for copper would suggest Cu $4s_{2}$ $3d_{9}$. However, the \ttt{sigma\_config} string
says $4s_{1}$ $3d_{10}$.
Mind that only the last warning is quoted in the warning summary at the programs end.
Furthermore, there is a phantom occupation number \ttt{2e-99} on the shallow $4p$ orbital.
This number is too small to influence \ttt{atom\_core} results but becomes relevant during \ac{PAW} generation.

\newpage

\subsection{Example output for \ttt{single\_atom}} \label{sec:example-output-for-single-atom}
% %%% ./a43 -t single_atom +verbosity=2 +element_Cu="4s* 1 0 4p* 2e-99 3d* 10 | 2.0 sigma 0.75" +logder.step=1e-4
\small
%%% +element_Cu="4s* 1 0 4p* 2e-99 3d* 10 | 2.0 sigma 0.75" +logder.step=1e-4
\begin{verbatim}
# verbosity=2
# test_LiveAtom: Z = 29
#
# Cu LiveAtom with 29 protons
# Cu radial grid up to 14.173 Bohr
# Cu radial grid numbers are 1541 and 956
# Cu radial grid numbers are 1544 and 956 (padded to align)
# Cu got PAW configuration data for Z=29: rcut=2 sigma=0.75 Bohr
# Cu projectors are expanded up to numax= 4
# Cu radial density and potentials are expanded up to lmax= 8 and 8, respectively
# Cu compensation charges are expanded up to lmax= 4
# Cu pseudize the core density at r[1344 or 759]= 1.996384, requested 2.000 Bohr
# Cu number of projectors per ell  2 2 2 0 0
# Cu valence  4s     1.0 E=       -0.178187 Ha
# Cu valence  5s     0.0 E=        0.017707 Ha
# Cu valence  4p     0.0 E=       -0.027887 Ha
# Cu valence  5p     0.0 E=        0.056131 Ha
# Cu valence  3d    10.0 E=       -0.195561 Ha
# Cu valence  4d     0.0 E=        0.054214 Ha
# Cu matrix size for hamiltonian and overlap: dim= 35, stride= 36

# Cu update_projector_coefficients Z=29

# Cu fit_function_set numerical projectors
# Cu for the s*-partial wave integrate outwards at E= 0.821813 Ha
# Cu for the p*-partial wave integrate outwards at E= 0.972113 Ha
# Cu for the d*-partial wave integrate outwards at E= 0.804439 Ha

# Cu check_spherical_matrix_elements: eigenstate_analysis with 384 points
# Cu eigenstate_analysis nr=384 dr=0.036813 rmax=14.1362 Bohr
# Cu lowest s-eigenvalues  -0.178242  0.021529  0.134882  0.311492  0.549549  Ha
# Cu lowest p-eigenvalues  -0.027974  0.064812  0.192389  0.379556  0.624611  Ha
# Cu lowest d-eigenvalues  -0.197324  0.059721  0.158684  0.313471  Ha
# Cu lowest f-eigenvalues   0.108270  0.233866  0.411101  0.639451  Ha
# Cu lowest g-eigenvalues   0.158377  0.314015  0.521262  Ha
# Cu lowest h-eigenvalues   0.212420  0.397089  0.632673  Ha

# Cu check_spherical_matrix_elements: logarithmic_derivative
# Cu logarithmic_derivative energy range from -2 to 1 Ha in 30.001 k steps of 0.1 mHa, ellmax=5
# Cu logarithmic_derivative check at radius 4.48769 Bohr
# Cu absolute largest logder difference is 12.1 mHa = 121 * 0.1 mHa found in the f-channel

# Cu run single_atom.init.max.scf=0 initial SCF-iterations

#    module= single_atom              status= 0
# 0 warnings have been recorded.
\end{verbatim}
\normalsize
%

\newpage

\subsection{Example output for \ttt{geometry\_analysis}} \label{sec:example-output-for-geometry-analysis}
% %%% ./a43 -t geometry_analysis +geometry.file=geo/Cu320Zr180.xyz +output.length.unit=Ang
\small
\begin{verbatim}
# ../src/a43 -t geometry_analysis +geometry.file=geo/Cu320Zr180.xyz +output.length.unit=Ang
# no control file given
# ../src/a43 git checkout 54f7de72061aca6983604646dff204d9e497d5b2

# verbosity=3

# run unit tests for module 'geometry_analysis'

# interpret "p" as periodic boundary condition in x-direction
# interpret "p" as periodic boundary condition in y-direction
# interpret "p" as periodic boundary condition in z-direction
# found 500 atoms in file "geo/Cu320Zr180.xyz" with cell=[19.929 19.929 19.929] Ang and bc=[1 1 1]

# geometry_analysis.cxx:analysis
# Found 2 different elements in 500 atoms:    Cu_320  Zr_180
# checked 6.750000 M atom-atom pairs, 35.020 k near and 6.714980 M far

# bond counts        Cu      Zr
# bond count       1886    1918  Cu sum= 3804
# bond count               1040  Zr sum= 2958
# bond counts      3804    2958   total= 6762

#  min distances     Cu      Zr
#  min distance   2.181   2.489  Cu in Ang
#  min distance           2.943  Zr in Ang

#  longest bonds     Cu      Zr
#  longest bond   3.297   3.837  Cu in Ang
#  longest bond           4.373  Zr in Ang

# shortest bonds     Cu      Zr
# shortest bond   2.181   2.489  Cu in Ang
# shortest bond           2.943  Zr in Ang

# bond table:
# pair, min dist, bond stats in Ang
#  Cu-Cu    2.181   2.641 +/- 0.182 in [2.181, 3.297]  1886 bonds
#  Cu-Zr    2.489   2.963 +/- 0.288 in [2.489, 3.837]  1918 bonds
#  Zr-Zr    2.943   3.421 +/- 0.389 in [2.943, 4.373]  1040 bonds
# total= 6762 bonds

#    module= geometry_analysis        status= 0

# 0 warnings have been recorded.
\end{verbatim}
\normalsize

\newpage
\begin{landscape}
\subsection{Example output for \ttt{radial\_eigensolver}} \label{sec:example-output-for-radial-_eigensolver}
% %%%% ./a43 -t radial_eigensolver +radial_eigensolver.test.Z=100
\small
\begin{verbatim}
# radial_eigensolver.cxx test_hydrogen_like_potential (Z=100) non-relativistic
\end{verbatim}
%
%%%% from https://tex.stackexchange.com/questions/156767/multiple-columns-with-minipage-cant-use-100-of-textwidth
\noindent
\begin{minipage}[t]{.7\textwidth}
\raggedright
%
\begin{verbatim}
#  1 -energy -5000.000000000000 Ha analytical
#  1s-energy -4999.999999999996  dev 3.6e-12 Ha
#  2 -energy -1250.000000000000 Ha analytical
#  2s-energy -1250.000002608134  dev -2.6e-06 Ha
#  2p-energy -1250.000000864512  dev -8.6e-07 Ha
#  3 -energy -555.555555555556 Ha analytical
#  3s-energy -555.555562762060  dev -7.2e-06 Ha
#  3p-energy -555.555559359189  dev -3.8e-06 Ha
#  3d-energy -555.555556392101  dev -8.4e-07 Ha
#  4 -energy -312.500000000000 Ha analytical
#  4s-energy -312.500013968428  dev -1.4e-05 Ha
#  4p-energy -312.500009441156  dev -9.4e-06 Ha
#  4d-energy -312.500003903630  dev -3.9e-06 Ha
#  4f-energy -312.500000729428  dev -7.3e-07 Ha
#  5 -energy -200.000000000000 Ha analytical
#  5s-energy -200.000022753883  dev -2.3e-05 Ha
#  5p-energy -200.000017592622  dev -1.8e-05 Ha
#  5d-energy -200.000010050054  dev -1.0e-05 Ha
#  5f-energy -200.000003687713  dev -3.7e-06 Ha
#  5g-energy -200.000000632147  dev -6.3e-07 Ha
#  6 -energy -138.888888888889 Ha analytical
#  6s-energy -138.888922437307  dev -3.4e-05 Ha
#  6p-energy -138.888916890362  dev -2.8e-05 Ha
#  6d-energy -138.888907982484  dev -1.9e-05 Ha
#  6f-energy -138.888898816611  dev -9.9e-06 Ha
#  6g-energy -138.888892305181  dev -3.4e-06 Ha
#  6h-energy -138.888889440679  dev -5.5e-07 Ha
\end{verbatim}
%
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.7\textwidth}
\raggedleft
%
\begin{verbatim}
#  7 -energy -102.040816326531 Ha analytical
#  7s-energy -102.040862672379  dev -4.6e-05 Ha
#  7p-energy -102.040856904693  dev -4.1e-05 Ha
#  7d-energy -102.040846996754  dev -3.1e-05 Ha
#  7f-energy -102.040835734864  dev -1.9e-05 Ha
#  7g-energy -102.040825875018  dev -9.5e-06 Ha
#  7h-energy -102.040819471332  dev -3.1e-06 Ha
#  7i-energy -102.040816813684  dev -4.9e-07 Ha
#  8 -energy -78.125000000000 Ha analytical
#  8s-energy -78.125061081898  dev -6.1e-05 Ha
#  8p-energy -78.125055125070  dev -5.5e-05 Ha
#  8d-energy -78.125044577429  dev -4.5e-05 Ha
#  8f-energy -78.125031723962  dev -3.2e-05 Ha
#  8g-energy -78.125019154014  dev -1.9e-05 Ha
#  8h-energy -78.125009078651  dev -9.1e-06 Ha
#  8i-energy -78.125002886225  dev -2.9e-06 Ha
#  8j-energy -78.125000435140  dev -4.4e-07 Ha
#  9 -energy -61.728395061728 Ha analytical
#  9s-energy -61.728472881346  dev -7.8e-05 Ha
#  9p-energy -61.728466782896  dev -7.2e-05 Ha
#  9d-energy -61.728455806989  dev -6.1e-05 Ha
#  9f-energy -61.728441693685  dev -4.7e-05 Ha
#  9g-energy -61.728426933448  dev -3.2e-05 Ha
#  9h-energy -61.728413640858  dev -1.9e-05 Ha
#  9i-energy -61.728403628371  dev -8.6e-06 Ha
#  9j-energy -61.728397729906  dev -2.7e-06 Ha
#  9k-energy -61.728395453327  dev -3.9e-07 Ha
\end{verbatim}
%
\end{minipage}
%
\begin{verbatim}
# test_hydrogen_like_potential: largest energy deviation for non-relativistic solver is 7.8e-05 Ha
\end{verbatim}
\normalsize
\end{landscape}

\newpage

The \ttt{radial\_eigensolver} has two relevant operations modes: \ttt{non}-\ttt{relativistic} and \ttt{scalar}-\ttt{relativistic}. Figure \ref{fig:radial-eigensolver-Z100-state-diagram} shows their difference for heavy atoms.
%% \ttt{linearized}-\ttt{sqrt} is an approximation for compute speed:
%% the relativistic mass m = m0*sqrt(1 + (v/c)^2) 
%%    is approximated as m = m0*(1 + 0.5*(v/c)^2)
%% The effect is tiny for atoms below Z=30
\begin{figure}[t]
	\centering
	\includegraphics[width=.5\textwidth]{fig/radial_eigensolver_Z100_state_diagram}
	%% generated: -D PLOT_STATE_DIAGRAM
	%% ./a43 --test radial_eigensolver +radial_eigensolver.test.Z=100
	\label{fig:radial-eigensolver-Z100-state-diagram}
	\caption{State diagram for a bare Coulomb potential $V(r) = -Z/r$ (no screening, dashed black line) 
			 of a heavy core, $Z$=100.
			 In the \ttt{non}-\ttt{relativistic} approximation (Schr\"{o}dinger equation)
			 the hydrogen-like energy levels $E_{n\ell}$ are analytically known as $-{Z^2}/({2n^2})$,
			 independent of $\ell$ (solid black lines).
			 With the \ttt{scalar}-\ttt{relativistic} solver the energy levels are found below $E_{n\ell}$
			 and the $\ell$-degeneracy is lifted (solid orange lines).
	         }
\end{figure}

\subsection{Example output for \ttt{fermi\_distribution}} \label{sec:example-output-for-fermi-distribution}
%
\begin{figure}[h]
	\centering
	\includegraphics[width=.5\textwidth]{fig/Fermi-Dirac-distribution}
	\label{fig:Fermi-Dirac-distribution}
	\caption{Fermi-Dirac distribution function and its energy derivative.
		     The energy is given in units of the smearing temperature $k\um{B}T$.
	         }
\end{figure}
%
See Figure \ref{fig:Fermi-Dirac-distribution} for a plot of the Fermi-Dirac distribution function.

\newpage

\subsection{Example output for \ttt{MODULE\_NAME}} \label{sec:example-output-for-MODULE-NAME}
%
\small
\begin{verbatim}
\end{verbatim}
\normalsize

%\newpage
%\printglossary[type=\acronymtype]
%\printglossary


\newpage
% ==============================================================================
\bibliographystyle{plain} 
\bibliography{literature}
% ==============================================================================

\end{document}
